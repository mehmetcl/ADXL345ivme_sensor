/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 * Ali Ekrem GOKALP
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stm32f411xx.h"
#include "stm32f411xx_gpio.h"
#include "utility.h"
#include "spi.h"
#include "adxl345_odev.h"


int16_t x,y,z;
uint8_t RxData[6];
float   x_acc,y_acc,z_acc;



int main(void)

{
	//GPIO A PINLERI TANIMLAMA
	//PA 4 : CHIP SELECT PINI SPI1 AYARLANDI
	//PA 5 : CLOK PINI SPI1 AYARLANDI
	//PA 6 : MISO PINI SPI1 AYARLANDI
	//PA 7 : MOSI PINI SPI1 AYARLANDI

	// GPIO A CLOCK ENABLE
 	RCC->AHB1ENR |= (1U << 0);


	//PA4 OUTDRAIN
	GPIOA->MODER &= ~(1U<<9);
	GPIOA->MODER |= (1U<<8);
	//GPIOA->OTYPE |= (1U<<4);

	//PA5 ALTERNATE
	GPIOA->MODER &= ~(1U<<10);
	GPIOA->MODER |= (1U<<11);

	GPIOA->AFR[0] |= (1U<<20);
	GPIOA->AFR[0] &= ~(1U<<21);
	GPIOA->AFR[0] |= (1U<<22);
	GPIOA->AFR[0] &= ~(1U<<23);

	//PA6 ALTERNATE
	GPIOA->MODER &=~(1U<<12);
	GPIOA->MODER |= (1U<<13);

	GPIOA->AFR[0] |= (1U<<24);
	GPIOA->AFR[0] &= ~(1U<<25);
	GPIOA->AFR[0] |= (1U<<26);
	GPIOA->AFR[0] &= ~(1U<<27);

	//PA7 ALTERNATE
	GPIOA->MODER &=~(1U<<14);
	GPIOA->MODER |= (1U<<15);

	GPIOA->AFR[0] |= (1U<<28);
	GPIOA->AFR[0] &= ~(1U<<29);
	GPIOA->AFR[0] |= (1U<<30);
	GPIOA->AFR[0] &= ~(1U<<31);

	//SPI AYARLARI

	SPI_Handle_t spi = {{SPI1},{SPI_DEV_MASTER,SPI_DIRECTION_2LINES,SPI_DATASIZE_8BIT,SPI_PHASE_LOW,SPI_POLARITY_HIGH,SPI_SSM_ENABLE,SEKIZ,SPI_MSB_FIRST}};
	spi_init(&spi);

	//SPI ENABLE
	spi_enable_disable(SPI1, ENABLE);

	//ADXL DATA AYARLARI
	adxl345_init();


    while(1)
    {
    		//ADXL READ
    	 	 adxl345_read(0x32,RxData);
    	 	 x = ((RxData[1]<<8)|RxData[0]); // DATA X0, X1
    	     y = ((RxData[3]<<8)|RxData[2]); // DATA Y0, Y1
    	     z = ((RxData[5]<<8)|RxData[4]); // DATA Z0, Z1


    	     // 10 bit çözünürlükte scalar faktör durumu etki etmektedir.  Çözünürlük için her bir ekseni 0.0078 ile çarpmam gerek.

    	      x_acc= x * 0.0078;
    	      y_acc= y * 0.0078;
    	      z_acc= z * 0.0078;

    	       DELAY_MILISECOND(500);
    	}



}


